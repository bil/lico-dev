# __DRIVER_CODE__ imports
import time

# __DRIVER_CODE__ variables


# __DRIVER_CODE__ setup

{% if async %}
sleep_duration = {{config["config"]["tick_len"]}} / (2. * 1e6)
{% endif %}

fc = 1.e6 / {{config["config"]["tick_len"]}}

signal_args = {{in_signal["args"]["signals"]}}
signals = []
sig_idxs = []
out_sig_names = {{source_args["out"]}}

for args in signal_args:
  fs = args["fs"]
  f = args["f"]
  # TODO only works for fs >= fc
  args["step"] = int(fs / fc)
  if args["type"] == "sine":
    t = np.linspace(0, 1, int(fs), endpoint=False)
    sig = args["amplitude"] * np.sin(2 * np.pi * f * t, dtype=np.float64) + args["offset"]
  else:
    raise NotImplementedError
  signals.append(sig)
  sig_idxs.append(0)

# __DRIVER_CODE__ read

  for i, args in enumerate(signal_args):
    # TODO set out_sigs directly
    # sigs[out_sig_names[i]] = signals[i][sig_idxs[i]:sig_idxs[i]+args["step"]]
    memcpy(
      inBuf,
      <void *><long>signals[i][sig_idxs[i]:sig_idxs[i]+args["step"]].__array_interface__["data"][0],
      args["step"] * 8
    )
    sig_idxs[i] += args["step"]
    if sig_idxs[i] >= args["fs"]:
      sig_idxs[i] = 0

{% if async %}
  time.sleep(sleep_duration)
{% endif %}
