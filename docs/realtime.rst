###############################################################################
Why Realtime?
###############################################################################

*Realtime computing* refers to systems that include *guarantees* around the timing of operations. In such a system, the critical (longest) path of a block of code must complete in a given timeframe, defined by a realtime clock. In *hard* realtime systems, violations of this timing guarantee constitute a critical error that will crash the program, whereas in *soft* realtime systems, some timing violations may be tolerated and dealt with by error handling. LiCoRICE supports both of these paradigms.

Various applications across fields require timing guarantees when performing computation. Common examples of realtime systems include cruise control, thermostats, and pacemakers. LiCoRICE was born out of the need to prototype realtime systems for systems neuroscience experiments that log and process neural data on the order of Gb/s. Since `neurons generally fire at a maximum of several hundred Hertz <https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5067378/>`_, LiCoRICE has been rigorously tested down to the level of single millisecond (1kHz timer).

Conventional hardware and operating systems are not suitable for hard realtime programming out-of-the-box and require a kernel patch to achieve consistent timing across indefinite periods of time. The standard Linux kernel performs a number of tasks behind the scenes that are by default not preemptible by the user, such as turning on fans. The PREEMPT_RT kernel patch makes the entire Linux kernel preemptible, save for a few critical sections, meaning that user-space applications can take precedence and complete their realtime processing within the given time bounds.
