# cimport C libraries
from libc.stdio cimport printf, stdout, fflush
from libc.stdlib cimport exit, malloc, free
from libc.stdint cimport int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t
from libc.signal cimport SIGINT, SIGUSR1, SIGALRM, SIGBUS, SIGSEGV, SIGQUIT, SIGUSR2, SIGSTOP, SIGCONT
from libc.string cimport memset, memcpy
from libc.errno cimport errno, EINTR, EPIPE, EAGAIN
from posix.signal cimport kill, sigaction, sigaction_t, sigset_t, sigemptyset, sigaddset, sigfillset
from posix.unistd cimport getppid, pause, close, getpid, read
from posix.mman cimport shm_open, mmap, munmap, PROT_READ, PROT_WRITE, MAP_SHARED, mlockall, MCL_CURRENT, MCL_FUTURE, munlockall
from posix.types cimport pid_t
from posix.fcntl cimport O_RDWR, open, fcntl, O_RDONLY, F_SETFL, O_NONBLOCK
from posix.ioctl cimport ioctl
from posix.time cimport clock_gettime, CLOCK_MONOTONIC_RAW, timespec
from libcpp cimport bool

#import python libraries
import numpy as np
import SharedArray
import socket
import netifaces
import posix_ipc 
import time
import signal
import os
import sys

#Import C utility functions 
cdef extern from "utilityFunctions.h":
	void init_utils(void (*pHandleExit)(int exitStatus), sigset_t *pExitMask)
	void die(char *errorStr)
	void open_shared_mem(uint8_t **ppmem, const char *pName, int numBytes, int shm_flags, int mmap_flags)
	void set_sighandler(int signum, void *psh, sigset_t *block_mask)
	void make_realtime()

#Import constants
cdef extern from "constants.h":
	enum: NUM_CHANNELSf
	enum: MAX_PATH_LEN
	enum: PAGESIZE
	enum: INIT_BUFFER_TICKS
	enum: BYTES_PER_FRAME
	const char *SMEM0_PATHNAME
	enum: NUM_NON_SOURCES
	enum: NUM_SEM_SIGS
	enum: NUM_INTERNAL_SIGS
	size_t ROUND_UP(int X, int Y)
	enum: BUF_VARS_LEN

#define the exitMask
cdef public sigset_t exitMask

cdef void handle_exit(int exitStatus):
	sem.unlink()
	{{destuct_code}}
	exit(exitStatus)

cdef void exit_handler(int signum):
	printf("EXIT HANDLER for %s\n", "{{name}}")
	handle_exit(0)

#setup mask for signal handlers
sigfillset(&exitMask)
init_utils(&handle_exit, &exitMask)
# handle signals
set_sighandler(SIGUSR1, &exit_handler, &exitMask)

#Variable Initialization
{% set sig_type = in_signal['args']['type'] -%}

#Set up Shared Array Path and Semaphore path
created_mem = SharedArray.list()
{% for sig,args in (out_signals.items()) %}	#Are we guareenteed to have one output signal? or could there be more?

SA_PATH = "shm://io.{{sig}}"
SA_PATH_LEN = "shm://io.{{sig}}.len"
SEM_NAME = "/{{sig}}.sem"

#Delete shared memory arrays if they already exist
if any(['io.{{sig}}' == x[0] for x in created_mem]):
	SharedArray.delete("io.{{sig}}")
	die("{{sig}} SharedArray already created\n")
if any(['io.{{sig}}len' == x[0] for x in created_mem]):
	SharedArray.delete("io.{{sig}}.len")

{%- endfor %}

{% if sig_type == 'udp' -%}
MAX_NUM_PACKETS_PER_MS = {{in_signal['schema']['packets_per_tick']}}
PACKET_SIZE = {{in_signal['schema']['data']['size']}}
k = -1

#setup shared arrays
#Todo: More than one signal in input (is this even a posibility????)
{{name}}_len = SharedArray.create(SA_PATH_LEN, shape = 2*MAX_NUM_PACKETS_PER_MS, dtype = np.{{in_dtype}}) 
{{name}}_raw = SharedArray.create(SA_PATH, shape = (MAX_NUM_PACKETS_PER_MS, PACKET_SIZE), dtype = np.{{in_dtype}})

#setup shared sempahore
sem = posix_ipc.Semaphore(name=SEM_NAME, flags = posix_ipc.O_CREX)
sem.release()

{{construct_code}}

{% endif %} 

#signal to parent that setup is done
os.kill(os.getppid(), signal.SIGUSR2)

while True:
	#Parser code should read in the data from the non-real-time source and update the length and raw data shared arrays 
	{%- if has_parser %}
	{{parser_code}}
	{%- else %}
	die("Must specicify parser code for non real time source\n")
	{%- endif %}

